---
permalink: /lambda/1
layout: default
---


# Eliminating data types

The most amazing experience I had learning Haskell was discovering _how little_ there is to it. What would be primitive syntactic sugars, like `($)`, are defined within Haskell itself. Functions and algebraic data types, that is pretty much all there is to it. But one of them is more important than the other. This post will show how to replace algebraic data types with functions.

### Booleans

Booleans are the simplest nontrivial data type (the simplest begin `()`). It is easy to define them using algebraic data types:

```
data Bool
  = True
  | False
```

To replace it with a function, we must understand how booleans are used. The universal use case of algebraic data types is pattern matching. We could, however, replace pattern matching with the given function:

```
elimBool :: Bool -> a -> a -> a
elimBool True tt ff = tt
elimBool False tt ff = ff
```

This function _eliminates_ boolean values. Now, we can write a very funny looking `not` function:

```
not :: Bool -> Bool
not b = elimBool b False True
```

or an `and` function:

```
and :: Bool -> Bool -> Bool
and b1 b2 = elimBool b1 b2 False
```

By removing pattern matching, we removed the defining characteristic of algebraic data types losing no functionality. Consider the conjecture: data types _are_ their eliminators. Let's put it to the test.

    {-# LANGUAGE RankNTypes #-}

    -- Hide most of prelude to avoid name conflicts.
    import Prelude (($), String)

    type Bool = forall a. a -> a -> a

    true :: Bool
    true = \tt ff -> tt

    false :: Bool
    false = \tt ff -> ff

    showBool :: Bool -> String
    showBool b = b "True" "False"

Now, let's define a few common functions:

    not :: Bool -> Bool
    not b = \tt ff -> b ff tt

    (&&) :: Bool -> Bool -> Bool
    b1 && b2 = \tt ff -> b1 (b2 tt ff) ff

    (||) :: Bool -> Bool -> Bool
    b1 || b2 = \tt ff -> b1 tt (b2 tt ff)

    infixr 3 &&
    infixr 2 ||

```
Î»> showBool $ true && (false || true)
"True"
```

<!--

Turing machines versus lambda calculus
- Lambda calculus predates Turing machines
- Alonzo Church was Alan Turing's PhD adviser

-->
