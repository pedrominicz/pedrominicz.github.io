---
permalink: /lambda/1
layout: default
---

# Eliminating data types

The most amazing experience I had learning Haskell was discovering _how little_ there is to it. Functions and data types, that is pretty much all there is to it. But there could be even less. This post will show how to replace data types with functions.

### Booleans

Booleans are the simplest nontrivial data type (the simplest begin `()`). It is easy to define them using `data`:

```
data Bool
  = True
  | False
```

To replace them with a function, we must understand how they are used. The universal use case of data types is pattern matching. We could, however, replace pattern matching with the given function:

```
elimBool :: Bool -> r -> r -> r
elimBool True tt ff = tt
elimBool False tt ff = ff
```

This function _eliminates_ boolean values into the resulting type `r`. With it we can write a very funny looking `not` function:

```
not :: Bool -> Bool
not b = elimBool b False True
```

or `(&&)`:

```
(&&) :: Bool -> Bool -> Bool
b1 && b2 = elimBool b1 b2 False
```

By removing pattern matching, we removed the defining characteristic of data types without losing any functionality. I conjecture that data types _are_ their eliminators. Let's put it to the test.

    {-# LANGUAGE RankNTypes #-}

    import Prelude hiding ((&&), (||), Bool, Maybe)

    type Bool = forall r. r -> r -> r

    true :: Bool
    true = \tt ff -> tt

    false :: Bool
    false = \tt ff -> ff

    showBool :: Bool -> String
    showBool b = b "True" "False"

Now, let's define a few common functions:

    not :: Bool -> Bool
    not b = \tt ff -> b ff tt

    (&&) :: Bool -> Bool -> Bool
    b1 && b2 = \tt ff -> b1 (b2 tt ff) ff

    (||) :: Bool -> Bool -> Bool
    b1 || b2 = \tt ff -> b1 tt (b2 tt ff)

    infixr 3 &&
    infixr 2 ||

```
λ> showBool (true && (false || true))
"True"
```

Challenge: can you implement `()` using only functions? How would its eliminator look like?

### Maybe

Functions can also be used to represent polymorphic types. Let's consider how `Maybe` is pattern matched.

```
elimMaybe :: Maybe a -> (a -> r) -> r -> r
elimMaybe (Just x) f y = f x
elimMaybe Nothing f y = y
```

A `Maybe a` can be `Just x` or `Nothing`. If it is `Just x`, we may want to do something with `x` before producing the result, so we eliminate it using `f :: a -> r`. If it is nothing, we have no choice but to compute the result.

```
isJust :: Maybe a -> Bool
isJust x = elimMaybe x (const true) false
```

```
λ> showBool (isJust (Just true))
"True"
```

As with `Bool`, `elimMaybe` gives away how to implement `Maybe a` using only functions.

    type Maybe a = forall r. (a -> r) -> r -> r

    just :: a -> Maybe a
    just x = \f y -> f x

    nothing :: Maybe a
    nothing = \f y -> y

    showMaybe :: (Show a) => Maybe a -> String
    showMaybe x = x (\y -> "Just " ++ show y) "Nothing"

Note that `a` are universally quantified in different scopes. `Maybe a` is a type for all `a`, but `Maybe a` is the type of a "`Maybe`-shaped" function that can be eliminated to return a result `r` for all `r`.

Our `Maybe` is as general as the "normal" `Maybe`. In fact, it is a monad:

```
fmap :: (a -> b) -> Maybe a -> Maybe b
fmap g x = \f y -> x (f . g) y

return :: a -> Maybe a
return x = \f y -> f x

join :: Maybe (Maybe a) -> Maybe a
join x = \f y -> x (\x -> x f y) y
```

(Unfortunately, Haskell doesn't support polymorphic type synonyms instances.)

Challenge: can you implement `Either a b` using only functions? How would its eliminator look like?

### Natural numbers

<!--

Turing machines versus lambda calculus
- Lambda calculus predates Turing machines
- Alonzo Church was Alan Turing's PhD adviser

-->
